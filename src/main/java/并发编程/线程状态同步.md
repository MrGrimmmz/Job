###线程有几种状态？
- NEW （新建状态）
    - 即新建状态，是线和被创建旦未启动的状态。
- RUNNABLE （就绪状态）
    - 即就绪状态， 是调用start（） 之后运行之前的状态。
- RUNNING （运行状态）
    - 即运行状态， 是run （） 正在执行时线程的状态。线程可能会由于某些因素而退出RUNNING ，如时间、异常、锁、调度等。
    
- BLOCKED （阻塞状态）
    - 即阻塞状态， 进入此状态， 有以下种情况:
        - 同步阻塞:锁被其他线程占用。
        - 主动阻塞:调用Thread 的某些方法，主动让出CPU 执行权，比如sleep（） 、join（） 等。
        - 等待阻塞:执行了wait（）。
- DEAD （终止状态）
    - 即终止状态，是run （） 执行结束，或同异常退出后的状态， 此状态不可逆转。
       

![](../并发编程/线程的状态.jpg)

###线程同步的方式
- 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

- 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

- 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

###sleep和wait方法有什么区别
- 从使用角度看，sleep是Thread线程类的方法，而wait是Object顶级类的方法。
  sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用

- sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行
 
###join()
- join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。
 
###yield()
- 该方法与sleep()类似，也不会释放锁，不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。



