###独占锁和共享锁
####区别
* 独占锁同时只有一条线程可以acquire成功，共享锁同时可能有多条线程可以acquire成功，
Semaphore是典型例子
* 独占锁每次只能唤醒一个Node，共享锁每次唤醒的时候可以将状态向后传播，即可能唤醒多个Node，
CountDownLatch是典型例子

###悲观锁与乐观锁
####乐观锁
- 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现 

####悲观锁
- 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁

###适用场景

####乐观锁
- 比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

####悲观锁
- 比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

