####线程安全定义
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的。
####Java语言中的线程安全
* 不可变 
    - final关键字
    
* 绝对线程安全 
    - 不管运行环境如何，调用者都不需要任何额外的同步措施

* 相对线程安全
    - Java语言中，大部分的线程安全类都属于这个类型，比如Vector、HashTable,Collections.synchronizedCollection()方法包装的集合

* 线程兼容
    - 通过使用同步手段来保证对象在并发环境中可以安全调用

* 线程对立
    - 无论调用端是否采取同步措施，都无法在多线程环境中并发使用的代码

####线程安全的实现方法
* 互斥同步：临界区、互斥量、信号量
synchronized monitorenter和monitorexit
reentrantLock
ReentrantLock与synchronized的区别：
* 前者表现为API层面的互斥锁，后者表现为原生语法层面的互斥锁
ReentrantLock的优势：
可实现等待可中断 
可实现公平锁
锁绑定多个条件
* 非阻塞同步
CAS：compare and swap 比较并交换
CAS指令需要3个操作数：内存位置V、旧的预期值A和新值B
CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则就不执行更新
* 锁优化
适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁

自适应的自旋锁意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据是
逃逸分析技术。

锁粗化是指一系列的连续操作都对同一个对象反复加锁和解锁，就可以将加锁同步的范围扩展到整个操作的外面。

轻量级锁：对象头中的运行时数据成为“Mark World”，在代码进入同步快时，如果此对象没有被锁定，虚拟机首先将在当前的栈帧中建立
一个名为锁记录的空间，用于存储锁对象的Mark World的拷贝，然后，虚拟机将使用CAS操作尝试将对象的Mark World更新为指向锁记录空间
的指针，如果更新成功，那么该线程就拥有了该对象的锁了，并且将锁对象的标志位改为“00”，

偏向锁：虚拟机启用了偏向锁后，当锁对象第一次被线程获取的时候，虚拟机将对象头中的标志位设为01，即偏向模式，同时使用CAS操作将
线程的id保存到锁对象Mark world中，如果CAS成功，持有偏向锁的线程每次进入这个锁相关的同步块时，虚拟机不在执行任何同步操作。