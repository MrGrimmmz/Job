##锁
- 如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

- 不同的存储引擎支持不同的锁机制

###分类
- 表级锁
    - 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    
- 行级锁：
    - 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

###MyISAM实现了表锁

- 表共享锁（Table Read Lock）
- 表独占写锁（Table Write Lock）
  
    
###InnoDB实现了行锁与表锁（意向锁）
行锁分两种：

- 共享锁（读锁）：
    - 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。但允许其他事务获取共享锁。
    - 通过在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。
    - SELECT * from city where id = "1"  lock in share mode; 
    - 由于对于city表中,id字段为主键，就也相当于索引。执行加锁时，会将id这个索引为1的记录加上锁，那么这个锁就是行锁。

- 排他锁（写锁）：
    - 允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。但是可以对获取了排他锁的数据集进行单纯的查询访问。
    - 在需要执行的语句后面加上for update就可以了
    - 使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，
    MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键或索引，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。
    
- 对于 Update、Delete、insert 语句，InnoDB 会自动给涉及的数据集隐式的加上排他锁。

- 对于 select 语句 InnoDB 不会加任何锁。

###行锁与索引

在 InnoDB 中，行锁是通过给索引上的索引项加锁来实现的。
如果没有索引，InnoDB 将会通过隐藏的聚簇索引来对记录加锁。
另外，根据针对 sql 语句检索条件的不同，
加锁又有以下三种情形需要我们掌握。

- Record lock：对索引项加锁。
- Gap lock：对索引项之间的间隙加锁。
- Next-key lock：对记录记前面的间隙加锁。

###悲观锁
- 在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

####数据库悲观锁的流程
- 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
  
  如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
  
  如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
  
  其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

####MySQL InnoDB使用悲观锁
- 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;

```aidl
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)
//1.查询出商品信息
select status from t_goods where id=1 for update;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品status为2
update t_goods set status=2;
//4.提交事务
commit;/commit work;
```
- 我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁
- 使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

- 优点
    - 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。
- 缺点
    - 在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；
    - 在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；
    - 降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数
    
####MySQL InnoDB使用乐观锁
- 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚

- 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

- 使用版本号实现乐观锁
```aidl
1.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
2.根据商品信息生成订单
3.修改商品status为2
update t_goods 
set status=2,version=version+1
where id=#{id} and version=#{version};
```
- 优点
    - 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，
    直到提交的时候才去锁定，所以不会产生任何锁和死锁。
    - 但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

###使用场景
- 响应速度： 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。'
- 冲突频率： 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
- 重试代价： 如果重试代价大，建议采用悲观锁。

###数据库死锁及解决方法
[参考](https://www.cnblogs.com/wezheng/p/8366029.html)
