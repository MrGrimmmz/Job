##锁
- 如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

- 不同的存储引擎支持不同的锁机制

###分类
- 表级锁
    - 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
    
- 行级锁：
    - 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
    
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

###MyISAM实现了表锁

- 表共享锁（Table Read Lock）
- 表独占写锁（Table Write Lock）
  
    
###InnoDB实现了行锁与表锁（意向锁）
行锁分两种：

- 共享锁（s）：
    - 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。但允许其他事务获取共享锁。
- 排他锁（Ｘ）：
    - 允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。但是可以对获取了排他锁的数据集进行单纯的查询访问。

- 对于 Update、Delete、insert 语句，InnoDB 会自动给涉及的数据集隐式的加上排他锁。

- 对于 select 语句 InnoDB 不会加任何锁。

###行锁与索引

在 InnoDB 中，行锁是通过给索引上的索引项加锁来实现的。
如果没有索引，InnoDB 将会通过隐藏的聚簇索引来对记录加锁。
另外，根据针对 sql 语句检索条件的不同，
加锁又有以下三种情形需要我们掌握。

- Record lock：对索引项加锁。
- Gap lock：对索引项之间的间隙加锁。
- Next-key lock：对记录记前面的间隙加锁。
