##微服务架构风格一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。

###微服务与SOA区别

- 微服务，从本质意义上看，还是 SOA 架构。
- 但内涵有所不同，微服务并不绑定某种特殊的技术，在一个微服务的系统中，可以有 Java 编写的服务，
也可以有 Python编写的服务，他们是靠Restful架构风格统一成一个系统的。

- 所以微服务本身与具体技术实现无关，扩展性强。

###微服务的目的是有效的拆分应用，实现敏捷开发和部署 。

###微服务设计原则

- 单一职责原则

    - 意思是每个微服务只需要实现自己的业务逻辑就可以了，比如订单管理模块，它只需要处理订单的业务逻辑就可以了，其它的不必考虑。

- 服务自治原则

    - 意思是每个微服务从开发、测试、运维等都是独立的，包括存储的数据库也都是独立的，自己就有一套完整的流程，我们完全可以把它当成一个项目来对待。不必依赖于其它模块。

- 轻量级通信原则

    - 首先是通信的语言非常的轻量，第二，该通信方式需要是跨语言、跨平台的，之所以要跨平台、跨语言就是为了让每个微服务都有足够的独立性，可以不受技术的钳制。

- 接口明确原则

    - 由于微服务之间可能存在着调用关系，为了尽量避免以后由于某个微服务的接口变化而导致其它微服务都做调整，在设计之初就要考虑到所有情况，让接口尽量做的更通用，更灵活，从而尽量避免其它模块也做调整。
    
###客户端如何访问这些服务？（API Gateway）
一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括

- 提供统一服务入口，让微服务对前台透明

- 聚合后台的服务，节省流量，提升性能

- 提供安全，过滤，流控等API管理功能

###服务之间如何通信？（服务调用）
- REST（JAX-RS，Spring Boot）

- RPC（Thrift, Dubbo）

- 异步消息调用(Kafka, Notify)

###这么多服务怎么查找？（服务发现）
- 基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。
    - 当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，
    实时更新链接信息。
    - 服务调用者通过ZK寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。
    当服务下线时，ZK会发通知给服务客户端
    
    - zookeeper 与生俱来的容错容灾能力（比如leader选举），可以确保服务注册表的高可用性

###服务挂了怎么办？
- 重试机制

- 限流

- 熔断机制

- 负载均衡

- 降级（本地缓存） 这些方法基本上都很明确通用，就不详细说明了。比如Netflix的Hystrix：

###容错策略
在调用服务集群时，如果一个微服务调用异常，如超时，连接异常，网络异常等，则根据容错策略进行服务容错。目前支持的服务容错策略有快速失败，失效切换。如果连续失败多次则直接熔断，不再发起调用。这样可以避免一个服务异常拖垮所有依赖于他的服务。

###熔断
- 熔断技术可以说是一种“智能化的容错”，当调用满足失败次数，失败比例就会触发熔断器打开，有程序自动切断当前的RPC调用,来防止错误进一步扩大。实现一个熔断器主要是考虑三种模式，关闭，打开，半开。
- 熔断器的使用场景是调用可能失败的远程服务程序或者共享资源

###限流和降级
- 保证核心服务的稳定性。为了保证核心服务的稳定性，
随着访问量的不断增加，需要为系统能够处理的服务数量设置一个极限阀值，
超过这个阀值的请求则直接拒绝。

- 同时，为了保证核心服务的可用，可以对否些非核心服务进行降级，
通过限制服务的最大访问量进行限流，通过管理控制台对单个微服务进行人工降级

###API网关
- 将所有API调用统一接入到API网关层，有网关层统一接入和输出。

- 一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。

- 有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。

###超时和重试
- 一次正常的调用统计的耗时主要包括： ①调用端RPC框架执行时间 + ②网络发送时间 + ③服务端RPC框架执行时间 + ④服务端业务代码时间。

###线程池隔离
- 线程隔离的之间优势就是防止级联故障，甚至是雪崩。当网关调用N多个接口服务的时候，我们要对每个接口进行线程隔离。比如，我们有调用订单、商品、用户。那么订单的业务不能够影响到商品和用户的请求处理。如果不做线程隔离，当访问订单服务出现网络故障导致延时，线程积压最终导致整个服务CPU负载满。就是我们说的服务全部不可用了，有多少机器都会被此刻的请求塞满。那么有了线程隔离就会使得我们的网关能保证局部问题不会影响全局。

