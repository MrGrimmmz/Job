####IBatis和MyBatis对比

####Hibernate和MyBatis对比
#####开发速度对比：
Hibernate的真正掌握要比Mybatis难一些，Mybatis框架相对简单容易上手，但也相对简陋些
要根据项目需求去考虑选择哪个框架进行开发，比如：一个项目中用到sql都是比较简单的，复杂的查询基本没有，
那么选择hibernate效率就很快了，因为基本的SQL语句都已经封装好了，根本不需要去写sql语句；但是对于一个
大型项目，选择Mybatis就会加快很多，SQL语句的管理也比较方便
#####开发工作量对比：
hibernate和Mybatis都有相应的代码生成工具，可以生成简单基本的DAO层方法，针对高级查询，Mybatis需要手动
编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，无需关心SQL的生成和结果映射。
#####SQL优化对比：
Hibernate查询会将表中的所有字段查询出来，这一点会有性能消耗，HIbernate也可以自己写SQL来指定需要查询
的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按照需求来指定查询的
字段。
#####对象管理的对比：
Hibernate是完整的对象/关系映射解决方案，它提供了对象状态管理的功能，使开发者不再需要理会底层数据库系统的细节
使用Hibernate的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。
#####缓存对比：
Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。
Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),
对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。
二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。

####Struts2和SpringMVC

####单点登录CAS

####MyBatis常见面试题
1、#{}和${}的区别是什么？
${}是properties文件中的变量占用符，它可以用于标签属性值和SQL内部，属于静态文本替换。
而#{}是SQL的参数占位符，Mybatis会将SQL中的#{}替换为?号，在SQL执行之前会使用PreparedStatement的参数设置
方法，按序给sql的?号占位符设置参数值。
2、XMl文件中，除了常见的select、insert、update和delete标签之外，还有哪些标签
<resultMap> <sql> <include> <selectKey>,加上动态SQL的9个标签，<trim> <where> <set> <foreach> <if> <choose>
<when> <otherwise> <bind>，其中，<sql>为SQL片段标签，通过<include>标签引入SQL片段，<selectKey>为不支持
自增的主键生成策略标签。
3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？
Dao接口里的方法，参数不同时，方法能重载吗？
Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，
就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类
的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，
举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。
在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，
代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
4.Mybatis是如何进行分页的，分页插件的原理是什么
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在SQL内
直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截执行的SQL，然后
重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数。

####SpringMVC
1、SpringMVC的工作流程
用户发送请求至前端控制器DispatcherServlet -> DispatcherServlet收到请求调用HandlerMapping处理器映射器
 -> 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet
 -> DispatcherServlet调用HandlerAdapter处理器适配器 -> HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)
 -> Controller执行完成返回ModelAndView -> HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 
 -> DispatcherServlet将ModelAndView传给ViewResolver视图解析器 -> ViewResolver解析后返回具体View 
 -> DispatcherServlet根据View进行渲染视图 -> DispatcherServlet响应用户
 2、解决POST和GET请求中文乱码问题
 
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
  在web.xml中配置一个字符编码过滤器，将编码参数设置为utf-8即可，这就可以解决POST请求乱码问题
  对于get请求乱码问题解决方法：
  修改tomcat配置文件
  
    <ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>
   
   对参数进行重新编码
   
    String userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")

   3、SpringMVC和Struts2的区别
    SpringMVC的入口是一个servlet即前端控制器，而Struts2入口是一个filter过虑器。
    SpringMVC是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 
    Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，SpringMVC通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。
    
   
   ####搜索引擎选择：ElasticSearch与Solr
   Solr和ElasticSearch都是基于Lucene实现的
   Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。
   Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式。
   Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供
   Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch
   Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用
   Elasticsearch 采用 Gateway 的概念，使得完备份更加简单
   Elasticsearch和磁盘之间还有一层称为FileSystem Cache的系统缓存，正是由于这层cache的存在才使得es能够拥有更快搜索响应能力。
   Lucene是一个开源的全文检索引擎工具包，但是他不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，
   倒排索引由两部分组成：词典和倒排表
   词典结构要求是：1、查询速度；2、内存占用；3、内存+磁盘结合
   词典的数据结构：跳跃表和FST
   跳跃表：
        优点：结构简单、跳跃间隔、级数可控，Lucene3.0之前使用的也是跳跃表结构，后换成了FST，但跳跃表在Lucene其他地方还有应用如倒排表合并和文档号索引
        缺点：模糊查询支持不好
    FST：
        优点：内存占用率低，压缩率在3倍-20倍之间，模糊查询支持好，查询快
        缺点：结构复杂，输入要求有序，更新不易
     Lucene现在采用的是数据结构为FST，它的特点是：
        词查找复杂度为O(len(str);
        共享前缀、节省空间
        内存存放前缀索引、磁盘存放后缀词块
   ####消息服务：ActiveMQ，RabbitMQ和Kafka对比
   
   ####dubbo的负载均衡策略
       1> Random LoadBalance
       随机，按照权重设置随机概率
       在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
       2> RoundRobin LoadBalance
       轮循，按公约后的权重设置轮循比率
       存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
       3> LeastActive LoadBalance
       最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
       使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
       每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。
       4> ConsistentHash LoadBalance
       一致性Hash，相同参数的请求总是发到同一提供者。
       当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
   ####Nginx的负载均衡策略
        1> 轮询
        每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 
        2> 指定权重
        指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 
        3> IP绑定 ip_hash
        每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 
        4> fair（第三方）
        按后端服务器的响应时间来分配请求，响应时间短的优先分配。 
        5> url_hash（第三方）
        按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 
   ####SVN和Git对比
   集中式和分布式
   Git是目前世界上最先进的分布式版本控制系统，每个开发人员从中心版本库/服务器上check out代码后会在自己的机器上克隆一个跟中心版本库一模一样的本地版本库
   Git只关心文件数据的整体是否发生变化，而SVN这类版本控制系统则只关心文件内容的具体差异。
   在Git中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网。
   SVN断开网络或者断开VPN就无法commit代码，但是Git可以先commit到本地仓库。
   Git的内容完整性要优于SVN。
   Git克隆一个完整项目的速度非常快，SVN 非常慢。
   其中最重要的区别是在于Git 上的分支远比SVN上的强大。下面具体介绍分支的概念。
   在 SVN 这类的版本控制系统上，分支（branch）是一个完整的目录，且这个目录拥有完整的实际文件。
   如果工作成员想要开启新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。
   如果你的分支是用来对系统模块进行安全检查测试的，那将会像传染病一样，你改一个分支，
   还得让其他人重新切分支重新下载，而且这些代码很可能对稳定版本还是具有破坏性的。
   在 Git上，每个工作成员可以任意在自己的本地版本库开启无限个分支。只要我不合并及提交到主要版本库，
   没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可，无痛无痒。
   Git 中每个克隆(clone)的版本库都是平等的。可以从任何一个版本库的克隆来创建属于自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。
   Git 的每一次提取操作，实际上都是一次对代码仓库的完整备份。
   提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。
   Git 的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示你手工完成
   Git指令：
   创建仓库：mkdir nnn //仓库名
   仓库初始化：git init //初始化仓库
   克隆到本地库：git clone git@github.com:XXX/yyyy.git //XXX为github的用户名，yyy为仓库名
   提交到本地库：git commit -m "hhh" //hhh为git commit 提交信息，是对这个提交的概述
   查看仓库状态：git status //查看仓库状态
   推送到远程服务器仓库：git push //更新GitHub上的仓库
   创建分支：git checkout -b aaa //创建名为aaa的分支，并且切换到aaa分支
   切换分支：git checkout aaa // 切换到aaa分支
   显示分支：git branch //显示分支一览表，同时确认当前所在的分支
   回溯历史版本：git reset //回溯历史版本
    分支合并：git merge --no--ff aaa // 加--no--ff 参数可以在历史记录中明确地记录本次分支的合并
   