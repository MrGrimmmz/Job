###缓存穿透
* 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从
存储层查不到数据，则不写入缓存，这就导致这个不存在的数据每次请求都要到存储层取查询，失去了
缓存的意义。在流量大时，DB就会挂掉。
####解决方案
* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个
bitmap拦截掉，从而避免了对底层存储系统的查询压力，
* 如果一个查询返回的数据为空，仍然把这个空结果进行缓存，但它的过期时间很短。
###缓存雪崩
* 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部
转发到DB，DB瞬时压力过大雪崩。
####解决方案
* 考虑用加锁或者队列的方式保证缓存的单线程写
* 在原有失效时间基础上增加一个随机值，比如1-5分钟随机
###缓存击穿
* 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存
过期都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
####解决方案
* 使用互斥锁  就是在缓存失效的时候，不是立即去load db，而是先使用缓存工具的某些带成功操作
返回值的操作，比如Redis的SETNX去set一个mutex key，当操作返回成功时，在进行load db的操作并
回设缓存；否则，就重设整个get缓存的方法。注：SETNX是SET if Not eXists的缩写。
* 提前使用互斥锁  在value内部设置1个超时值（timeout1），timeout1比实际的Redis timeout小，
当从cache读取到timeout1发现它已经过期时，马上延长timeout1并重新设置到cache，然后再从数据库
加载数据并设置到cache中
* 永远不过期  两层意思：从Redis上看，确实没有设置过期时间，这就保证了不会出现热点key过期问题，
从功能上看，如果不过期，那不就成静态了，所以把过期时间存在key对应的value里，如果发现要过期了
通过一个后台的异步线程进行缓存的构建，也就是逻辑过期
* 资源保护  采用Netflix的Hystrix，可以做资源的隔离保护主线程池