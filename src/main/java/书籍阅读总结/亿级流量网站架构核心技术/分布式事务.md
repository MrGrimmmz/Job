###分布式事务
####数据库事务ACID
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）
####分布式理论
#####CAP定理
* 一致性（Consistency）
* 可用性（Availability）
* 分区容错性（Partition tolerance）
#####BASE理论
* Basically Available（基本可用）
* Soft state（软状态）
* Eventually consistent（最终一致性）
####分布式事务解决方案
#####两阶段提交（2PC）
* 两阶段提交使用了XA协议的原理，
* 第一阶段：事务协调器要求每个涉及到事务的数据库预提交此操作，并反映是否可以提交
* 第二阶段：事务协调器要求每个数据库提交事务
* 如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息
* 优点：尽量保证了数据的一致性，适合对数据强一致要求很高的关键领域
* 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合好并发高性能场景
#####补偿事务（TCC）
* 核心思想：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，它分为三个阶段：
    * Try阶段，主要是对业务系统做检测及资源预留
    * Confirm阶段，主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的
    * Cancel阶段，主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放
* 优点：和2PC比起来，实现和流程相对简单一些，但是数据的一致性比2PC要差一些
* 缺点：在Confirm和Cancel阶段有可能失败，TCC属于应用层的一种补偿方式，所以需要在实现的时候写很多补偿的代码
#####本地消息表（异步确保）
* 核心思想：将分布式事务拆分成本地事务进行处理
* 基本思路：
    * 消息生产方，需要额外建一个消息表，并记录消息发送状态，消息和业务数据要在一个事务里提交，然后消息会经过MQ发送到消息的消费方，如果消息发送失败，会进行重新发送
    * 消息消费方：需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行，如果是业务上面的失败，可以给发送方发送一个业务补偿消息，通知生产方进行回滚
    * 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息在发送一遍。
* 优点：避免了分布式事务，实现了最终一致性
* 缺点：消息表会耦合到业务系统中
#####Sagas事务模式
* 核心思想：拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由Sagas工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。