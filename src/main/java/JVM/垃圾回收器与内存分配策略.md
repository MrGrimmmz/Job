###垃圾收集器与内存分配策略
* 垃圾回收器关注的是Java堆和方法区的内存
####判断对象是否存活的算法
* 引用计数算法
    * 对象之间存在相互循环引用的问题
* 可达性分析算法
    * 基本思路就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜
    索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可
    用的
    * 可作为GC Roots的对象包括：
        * 虚拟机栈中引用的对象
        * 方法区中类静态属性引用的对象
        * 方法区中常量引用的对象
        * 本地方法栈中Native方法引用的对象
* 四种引用类型
    * 强引用 在程序代码中普遍存在的，只要强引用还存在，GC永远不会回收掉被引用的对象
    * 软引用 用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会
    把这些对象列进回收范围之中进行第二次回收
    * 弱引用 用来描述非必需对象的，但是它的强度比弱引用更弱一些，被弱引用关联的对象只能生存
    到下一次垃圾收集发生之前，当垃圾回收器工作时，无论当前内存是否足够，都会回收只被
    弱引用关联的对象
    * 虚引用 最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成
    影响，也无法通过虚引用取得一个对象实例。对一个对象设置虚引用关联的唯一目的就是能在
    这个对象被收集器回收时收到一个系统通知
* 生存or死亡
    * 在可达性分析算法中不可达的对象，还会进行一次筛选，筛选的条件是此对象是否有必要
    执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机
    调用过，虚拟机将这两两种情况都视为没有必要执行
    * 任何一个对象的finalize()方法都只会内系统自动调用一次
* 方法区的回收
    * 永久区的垃圾收集主要回收两部分内容：废弃常量和无用的类
    * 判断为无用的类要同时满足3个条件：
        * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
        * 加载该类的ClassLoader已经被回收
        * 该类对应的Class对象没有在任何地方被引用
####垃圾收集算法
#####标记-清除算法
* 两个不足：一是效率问题；二是空间问题
#####复制算法
* 将内存分为一块较大的Eden空间和两块较小的Survivor空间
* HotSpot虚拟机默认Eden和Survivor的大小比例是8:1
#####标记-整理算法
#####分代收集算法
####HotSpot的算法实现
#####枚举根节点
* 这项工作必须在一个能确保一致性的快照中进行，Sun将这件事情称为"Stop The World"
#####安全点
* 抢先式中断
* 主动式中断
#####安全区域
* 是指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的
####垃圾收集器
#####Serial收集器
* 这是最基本、发展历史最悠久的收集器，一个单线程的新生代收集器，采用复制算法
#####ParNew收集器
* 这是Serial收集器的多线程版本，新生代收集器，采用复制算法
* 并行和并发
    * 并行：指多条垃圾收集线程并行工作，，但此时用户线程仍然处于等待状态
    * 并发：指用户线程与垃圾收集线程同时执行
#####Parallel Scavenge收集器
* 新生代收集器，采用复制算法
* 目标是达到一个可控制的吞吐量 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
* 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间和直接设置吞吐量大小
* GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的
* 是以吞吐量优先的收集器
* GC自适应的调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数
以提供最合适的停顿时间或者最大的吞吐量
#####Serial Old收集器
* 是Serial的老年代版本，单线程收集器，采用"标记-整理"算法
#####Parallel Old收集器
* 是Parallel Scavenge收集器的老年代版本，使用多线程和"标记-整理"算法
#####CMS收集器
* 以获取最短回收停顿时间为目标的收集器
* 基于"标记-清除"算法实现的
* 整个过程分为四个步骤：
    * 初始标记
    * 并发标记
    * 重新标记
    * 并发清除
* 初始标记、重新标记这两个步骤仍然需要"Stop The World"
* 存在3个缺点：
    * CMS收集器对CPU资源非常敏感
    * 无法处理浮动垃圾
    * 基于"标记-清除"算法，存在大量空间碎片
#####G1收集器
* 并发与并行
* 分代收集
* 空间整合
* 可预测的停顿
* 运作主要分为4个步骤：
    * 初始标记
    * 重新标记
    * 最终标记
    * 筛选回收
####内存分配与回收策略
#####对象优先在Eden分配
* 当Eden区间没有足够空间时，虚拟机将发起一次Minor GC
* 如果在发生Minor GC期间，Eden区存活的对象无法放入Survivor区，那么可以通过分配担保机制
提前转移到老年代去
* 新生代GC(Minor GC): 指发生在新生代的垃圾收集动作
* 老年代GC(Major GC/Full GC): 指发生在老年代的GC
#####大对象直接进入老年代
* 需要大量连续内存空间的Java对象，如很长的字符串以及数组
#####长期存活的对象将进入老年代
* 虚拟机给每个对象定义了一个对象年龄计数器。
* 对象第一次被移动到Survivor区会将对象年龄设为1，对象在Survivor区中每熬过一次Minor GC
年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代
#####动态对象年龄判定
* 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于
该年龄的对象就可以直接进入老年代
#####空间分配担保
* 在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所欲对象总空间
如果这个条件成立，那么Minor GC是安全的，如果不成立，会继续检查老年代最大可用的连续空间
是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试分配担保；否则，进行一次Full GC
