
##垃圾收集器与内存分配策略
* 垃圾回收器关注的是Java堆和方法区的内存

###判断对象是否存活的算法
* 引用计数算法
    * 引用计数器
    * 主流虚拟机没有选择，因为难以解决对象之间存在相互循环引用的问题

* 可达性分析算法
    * 基本思路就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜
    索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可
    用的
    - 方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
    * 可作为GC Roots的对象包括：
        * 虚拟机栈中引用的对象
        * 方法区中类静态属性引用的对象
        * 方法区中常量引用的对象
        * 本地方法栈中Native方法引用的对象

* 四种引用类型
    * 强引用 
        - 在程序代码中普遍存在的，只要强引用还存在，GC永远不会回收掉被引用的对象
        - 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
    
    * 软引用 
        - 用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会
    把这些对象列进回收范围之中进行第二次回收
    
    * 弱引用 
        - 用来描述非必需对象的，但是它的强度比弱引用更弱一些，被弱引用关联的对象只能生存
    到下一次垃圾收集发生之前，当垃圾回收器工作时，无论当前内存是否足够，都会回收只被
    弱引用关联的对象
    
    * 虚引用 
        - 最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成
    影响，也无法通过虚引用取得一个对象实例。对一个对象设置虚引用关联的唯一目的就是能在
    这个对象被收集器回收时收到一个系统通知

- Java中提供这四种引用类型主要有两个目的：

    - 第一是可以让程序员通过代码的方式决定某些对象的生命周期；

    - 第二是有利于JVM进行垃圾回收。


* 生存or死亡
    * 在可达性分析算法中不可达的对象，还会进行一次筛选，筛选的条件是此对象是否有必要
    执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机
    调用过，虚拟机将这两种情况都视为没有必要执行
    * 任何一个对象的finalize()方法都只会内系统自动调用一次
    - finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。

* 方法区的回收
    * 永久区的垃圾收集主要回收两部分内容：废弃常量和无用的类
    * 判断为无用的类要同时满足3个条件：
        * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
        * 加载该类的ClassLoader已经被回收
        * 该类对应的Class对象没有在任何地方被引用

###HotSpot的算法实现

####枚举根节点
* 这项工作必须在一个能确保一致性的快照中进行，Sun将这件事情称为"Stop The World"

####安全点
* 抢先式中断
* 主动式中断

####安全区域
* 是指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的

###垃圾收集器
我们能做的就是根据具体应用场景选择适合自己的垃圾收集器

####Serial收集器
- 这是最基本、发展历史最悠久的收集器，一个单线程的新生代收集器，采用复制算法
- Stop The World带来的不良用户体验
- 它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择

####ParNew收集器
* 这是Serial收集器的多线程版本，新生代收集器，采用复制算法
* 并行和并发
    * 并行：指多条垃圾收集线程并行工作，，但此时用户线程仍然处于等待状态
    * 并发：指用户线程与垃圾收集线程同时执行
    
* 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作

####Parallel Scavenge收集器
* 新生代收集器，采用复制算法
* 目标是达到一个可控制的吞吐量 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
* 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间和直接设置吞吐量大小
* GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的
* 是以吞吐量优先的收集器
* GC自适应的调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数
以提供最合适的停顿时间或者最大的吞吐量

####Serial Old收集器
* 是Serial的老年代版本，单线程收集器，采用"标记-整理"算法

####Parallel Old收集器
* 是Parallel Scavenge收集器的老年代版本，使用多线程和"标记-整理"算法

####CMS收集器
* 以获取最短回收停顿时间为目标的收集器
* HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作
* 基于"标记-清除"算法实现的
* 整个过程分为四个步骤：
    * 初始标记
    * 并发标记
    * 重新标记
    * 并发清除
* 初始标记、重新标记这两个步骤仍然需要"Stop The World"
* 优点
    * 并发收集
    * 低停顿
* 存在3个缺点：
    * CMS收集器对CPU资源非常敏感
    * 无法处理浮动垃圾
    * 基于"标记-清除"算法，存在大量空间碎片

####G1收集器
* 一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.
* 特点
    * 并发与并行
    * 分代收集
    * 空间整合
    * 可预测的停顿
* 运作主要分为4个步骤：
    * 初始标记
    * 重新标记
    * 最终标记
    * 筛选回收
* G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）
    
