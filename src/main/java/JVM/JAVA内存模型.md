###什么是内存模型
- 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。

###什么是Java内存模型
- Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

- Java内存模型的主要目的
    - 是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
    - JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题
- Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，
- 每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量和主内存副本拷贝
- 线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。
- 不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成
- 线程、主内存和工作内存的交互关系如下图所示

![](交互关系.jpg)

- Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的
    - 原子性
        - 在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的
    - 可见性
        - volatile，Java中的synchronized和final关键字可以实现可见性
    - 有序性
        - 可以使用synchronized和volatile来保证多线程之间操作的有序性。
        - 实现方式有所区别：
            - volatile关键字会禁止指令重排。
            - synchronized关键字保证同一时刻只允许一条线程操作

###happens-before原则
- Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。

###”天然的“happens-before关系
a. 程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。

b. 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。

c. volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。

d. 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。

e. 线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。

f. 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。

g. 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。

h. 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

- 衡量并发安全问题一切必须以happens-before 原则为准

