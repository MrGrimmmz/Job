##堆内存
- 堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。

新生代
- Eden区
- Survivor1 区
- Survivor2 区   
                                                     
老年代

![](新生代老年代.png)

- 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

##垃圾收集算法
- 标记-清除算法
    * 两个不足：
        - 一是效率问题；
        - 二是空间问题（标记清除后会产生大量不连续的碎片）
- 复制算法
    * 将内存分为一块较大的Eden空间和两块较小的Survivor空间
    * HotSpot虚拟机默认Eden和Survivor的大小比例是8:1
    
- 标记-整理算法

###分代收集算法

- 新生代
    - Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。

- 新生代使用复制算法的原因
    - 主要是用来存放新生的对象，会频繁创建对象，所以垃圾收集会频繁进行回收。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

- 老年代
    - Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

- 老年代使用标记清除算法的原因
    - 老年代的对象存活率高，故垃圾收集不会频繁执行。因为老年代中对象存活率高、也没有额外空间对他进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法进行回收。使用复制算法则需要进行较多的复制操作，效率会变低。

##内存分配与回收策略

###对象优先在Eden分配
* 当Eden区间没有足够空间时，虚拟机将发起一次Minor GC
* 如果在发生Minor GC期间，Eden区存活的对象无法放入Survivor区，那么可以通过分配担保机制
提前转移到老年代去
* 新生代GC(Minor GC): 指发生在新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
* 老年代GC(Major GC/Full GC): 指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

###大对象直接进入老年代
* 需要大量连续内存空间的Java对象，如很长的字符串以及数组
* 为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

###长期存活的对象将进入老年代
* 虚拟机给每个对象定义了一个对象年龄计数器。
* 对象第一次被移动到Survivor区会将对象年龄设为1，对象在Survivor区中每熬过一次Minor GC
年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代

###动态对象年龄判定
* 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于
该年龄的对象就可以直接进入老年代

###空间分配担保
* 在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
如果这个条件成立，那么Minor GC是安全的，如果不成立，会继续检查老年代最大可用的连续空间
是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试分配担保；尽管有风险（因为判断的是平均大小，有可能这次的晋升对象比平均值大很多）；
如果小于，或者HandlePromotionFailure设置不允许空间分配担保，这时要进行一次FGC。
